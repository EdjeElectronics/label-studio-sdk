# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
import urllib.parse
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pagination import AsyncPager, SyncPager
from ..core.pydantic_utilities import pydantic_v1
from ..core.query_encoder import encode_query
from ..core.remove_none_from_dict import remove_none_from_dict
from ..core.request_options import RequestOptions
from ..errors.bad_request_error import BadRequestError
from ..types.annotation import Annotation
from ..types.base_task import BaseTask
from ..types.data_manager_task_serializer import DataManagerTaskSerializer
from ..types.prediction import Prediction
from ..types.project_import import ProjectImport
from ..types.task_simple import TaskSimple
from .types.tasks_create_many_response import TasksCreateManyResponse
from .types.tasks_list_response import TasksListResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class TasksClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def create_many(
        self,
        id: int,
        *,
        data: typing.Dict[str, typing.Any],
        import_api_id: typing.Optional[int] = OMIT,
        annotations: typing.Optional[typing.Sequence[Annotation]] = OMIT,
        predictions: typing.Optional[typing.Sequence[Prediction]] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        created_at: typing.Optional[dt.datetime] = OMIT,
        updated_at: typing.Optional[dt.datetime] = OMIT,
        overlap: typing.Optional[int] = OMIT,
        inner_id: typing.Optional[int] = OMIT,
        total_annotations: typing.Optional[int] = OMIT,
        cancelled_annotations: typing.Optional[int] = OMIT,
        total_predictions: typing.Optional[int] = OMIT,
        comment_count: typing.Optional[int] = OMIT,
        unresolved_comment_count: typing.Optional[int] = OMIT,
        last_comment_updated_at: typing.Optional[dt.datetime] = OMIT,
        updated_by: typing.Optional[int] = OMIT,
        file_upload: typing.Optional[int] = OMIT,
        comment_authors: typing.Optional[typing.Sequence[int]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TasksCreateManyResponse:
        """
        Import data as labeling tasks in bulk using this API endpoint. You can use this API endpoint to import multiple tasks.
        One POST request is limited at 250K tasks and 200 MB.
        
        **Note:** Imported data is verified against a project _label_config_ and must
        include all variables that were used in the _label_config_. For example,
        if the label configuration has a _$text_ variable, then each item in a data object
        must include a "text" field.
        <br>
        
        ## POST requests
        
        <hr style="opacity:0.3">
        
        There are three possible ways to import tasks with this endpoint:
        
        ### 1\. **POST with data**
        
        Send JSON tasks as POST data. Only JSON is supported for POSTing files directly.
        Update this example to specify your authorization token and Label Studio instance host, then run the following from
        the command line.
        
        ```bash
        curl -H 'Content-Type: application/json' -H 'Authorization: Token abc123' \
        -X POST 'https://localhost:8080/api/projects/1/import' --data '[{"text": "Some text 1"}, {"text": "Some text 2"}]'
        ```
        
        ### 2\. **POST with files**
        
        Send tasks as files. You can attach multiple files with different names.
        
        - **JSON**: text files in JavaScript object notation format
        - **CSV**: text files with tables in Comma Separated Values format
        - **TSV**: text files with tables in Tab Separated Value format
        - **TXT**: simple text files are similar to CSV with one column and no header, supported for projects with one source only
        
        Update this example to specify your authorization token, Label Studio instance host, and file name and path,
        then run the following from the command line:
        
        ```bash
        curl -H 'Authorization: Token abc123' \
        -X POST 'https://localhost:8080/api/projects/1/import' -F ‘file=@path/to/my_file.csv’
        ```
        
        ### 3\. **POST with URL**
        
        You can also provide a URL to a file with labeling tasks. Supported file formats are the same as in option 2.
        
        ```bash
        curl -H 'Content-Type: application/json' -H 'Authorization: Token abc123' \
        -X POST 'https://localhost:8080/api/projects/1/import' \
        --data '[{"url": "http://example.com/test1.csv"}, {"url": "http://example.com/test2.csv"}]'
        ```
        
        <br>
        
        Parameters
        ----------
        id : int
            A unique integer value identifying this project.
        
        data : typing.Dict[str, typing.Any]
            User imported or uploaded data for a task. Data is formatted according to the project label config. You can find examples of data for your project on the Import page in the Label Studio Data Manager UI.
        
        import_api_id : typing.Optional[int]
        
        annotations : typing.Optional[typing.Sequence[Annotation]]
        
        predictions : typing.Optional[typing.Sequence[Prediction]]
        
        meta : typing.Optional[typing.Dict[str, typing.Any]]
            Meta is user imported (uploaded) data and can be useful as input for an ML Backend for embeddings, advanced vectors, and other info. It is passed to ML during training/predicting steps.
        
        created_at : typing.Optional[dt.datetime]
            Time a task was created
        
        updated_at : typing.Optional[dt.datetime]
            Last time a task was updated
        
        overlap : typing.Optional[int]
            Number of distinct annotators that processed the current task
        
        inner_id : typing.Optional[int]
            Internal task ID in the project, starts with 1
        
        total_annotations : typing.Optional[int]
            Number of total annotations for the current task except cancelled annotations
        
        cancelled_annotations : typing.Optional[int]
            Number of total cancelled annotations for the current task
        
        total_predictions : typing.Optional[int]
            Number of total predictions for the current task
        
        comment_count : typing.Optional[int]
            Number of comments in the task including all annotations
        
        unresolved_comment_count : typing.Optional[int]
            Number of unresolved comments in the task including all annotations
        
        last_comment_updated_at : typing.Optional[dt.datetime]
            When the last comment was updated
        
        updated_by : typing.Optional[int]
            Last annotator or reviewer who updated this task
        
        file_upload : typing.Optional[int]
            Uploaded file used as data source for this task
        
        comment_authors : typing.Optional[typing.Sequence[int]]
            Users who wrote comments
        
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.
        
        Returns
        -------
        TasksCreateManyResponse
            Tasks successfully imported
        
        Examples
        --------
        from label_studio_sdk.client import LabelStudio
        
        client = LabelStudio(
            api_key="YOUR_API_KEY",
        )
        client.tasks.create_many(
            id=1,
            data={},
        )
        """
        _request: typing.Dict[str, typing.Any] = {"data": data}
        if import_api_id is not OMIT:
            _request["id"] = import_api_id
        if annotations is not OMIT:
            _request["annotations"] = annotations
        if predictions is not OMIT:
            _request["predictions"] = predictions
        if meta is not OMIT:
            _request["meta"] = meta
        if created_at is not OMIT:
            _request["created_at"] = created_at
        if updated_at is not OMIT:
            _request["updated_at"] = updated_at
        if overlap is not OMIT:
            _request["overlap"] = overlap
        if inner_id is not OMIT:
            _request["inner_id"] = inner_id
        if total_annotations is not OMIT:
            _request["total_annotations"] = total_annotations
        if cancelled_annotations is not OMIT:
            _request["cancelled_annotations"] = cancelled_annotations
        if total_predictions is not OMIT:
            _request["total_predictions"] = total_predictions
        if comment_count is not OMIT:
            _request["comment_count"] = comment_count
        if unresolved_comment_count is not OMIT:
            _request["unresolved_comment_count"] = unresolved_comment_count
        if last_comment_updated_at is not OMIT:
            _request["last_comment_updated_at"] = last_comment_updated_at
        if updated_by is not OMIT:
            _request["updated_by"] = updated_by
        if file_upload is not OMIT:
            _request["file_upload"] = file_upload
        if comment_authors is not OMIT:
            _request["comment_authors"] = comment_authors
        _response = self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/projects/{jsonable_encoder(id)}/import"
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(TasksCreateManyResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic_v1.parse_obj_as(str, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_many_status(
        self, id: int, import_pk: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ProjectImport:
        """
        Return data related to async project import operation

        Parameters
        ----------
        id : int
            A unique integer value identifying this project import.

        import_pk : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProjectImport


        Examples
        --------
        from label_studio_sdk.client import LabelStudio

        client = LabelStudio(
            api_key="YOUR_API_KEY",
        )
        client.tasks.create_many_status(
            id=1,
            import_pk="import_pk",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/projects/{jsonable_encoder(id)}/imports/{jsonable_encoder(import_pk)}/",
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(ProjectImport, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list(
        self,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        view: typing.Optional[int] = None,
        project: typing.Optional[int] = None,
        resolve_uri: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPager[typing.List[typing.Dict[str, typing.Any]]]:
        """
        Retrieve a list of tasks with pagination for a specific view or project, by using filters and ordering.

        Parameters
        ----------
        page : typing.Optional[int]
            A page number within the paginated result set.

        page_size : typing.Optional[int]
            Number of results to return per page.

        view : typing.Optional[int]
            View ID

        project : typing.Optional[int]
            Project ID

        resolve_uri : typing.Optional[bool]
            Resolve task data URIs using Cloud Storage

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPager[typing.List[typing.Dict[str, typing.Any]]]
            Tasks list

        Examples
        --------
        from label_studio_sdk.client import LabelStudio

        client = LabelStudio(
            api_key="YOUR_API_KEY",
        )
        client.tasks.list()
        """
        _response = self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/tasks/"),
            params=encode_query(
                jsonable_encoder(
                    remove_none_from_dict(
                        {
                            "page": page,
                            "page_size": page_size,
                            "view": view,
                            "project": project,
                            "resolve_uri": resolve_uri,
                            **(
                                request_options.get("additional_query_parameters", {})
                                if request_options is not None
                                else {}
                            ),
                        }
                    )
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            _parsed_response = pydantic_v1.parse_obj_as(TasksListResponse, _response.json())  # type: ignore
            _has_next = True
            _get_next = lambda: self.list(
                page=page + 1 if page is not None else 1,
                page_size=page_size,
                view=view,
                project=project,
                resolve_uri=resolve_uri,
                request_options=request_options,
            )
            _items = _parsed_response.tasks
            return SyncPager(has_next=_has_next, items=_items, get_next=_get_next)
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create(self, *, request: BaseTask, request_options: typing.Optional[RequestOptions] = None) -> BaseTask:
        """
        Create a new labeling task in Label Studio.

        Parameters
        ----------
        request : BaseTask

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BaseTask


        Examples
        --------
        from label_studio_sdk import BaseTask
        from label_studio_sdk.client import LabelStudio

        client = LabelStudio(
            api_key="YOUR_API_KEY",
        )
        client.tasks.create(
            request=BaseTask(
                data={},
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/tasks/"),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            json=jsonable_encoder(request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(BaseTask, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> DataManagerTaskSerializer:
        """
        Get task data, metadata, annotations and other attributes for a specific labeling task by task ID.

        Parameters
        ----------
        id : str
            Task ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DataManagerTaskSerializer


        Examples
        --------
        from label_studio_sdk.client import LabelStudio

        client = LabelStudio(
            api_key="YOUR_API_KEY",
        )
        client.tasks.get(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tasks/{jsonable_encoder(id)}/"),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(DataManagerTaskSerializer, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Delete a task in Label Studio. This action cannot be undone!

        Parameters
        ----------
        id : str
            Task ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from label_studio_sdk.client import LabelStudio

        client = LabelStudio(
            api_key="YOUR_API_KEY",
        )
        client.tasks.delete(
            id="id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            method="DELETE",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tasks/{jsonable_encoder(id)}/"),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            json=jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))
            if request_options is not None
            else None,
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(
        self, id: str, *, request: TaskSimple, request_options: typing.Optional[RequestOptions] = None
    ) -> TaskSimple:
        """
        Update the attributes of an existing labeling task.

        Parameters
        ----------
        id : str
            Task ID

        request : TaskSimple

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TaskSimple


        Examples
        --------
        from label_studio_sdk import TaskSimple
        from label_studio_sdk.client import LabelStudio

        client = LabelStudio(
            api_key="YOUR_API_KEY",
        )
        client.tasks.update(
            id="id",
            request=TaskSimple(
                data={},
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            method="PATCH",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tasks/{jsonable_encoder(id)}/"),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            json=jsonable_encoder(request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(TaskSimple, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncTasksClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def create_many(
        self,
        id: int,
        *,
        data: typing.Dict[str, typing.Any],
        import_api_id: typing.Optional[int] = OMIT,
        annotations: typing.Optional[typing.Sequence[Annotation]] = OMIT,
        predictions: typing.Optional[typing.Sequence[Prediction]] = OMIT,
        meta: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        created_at: typing.Optional[dt.datetime] = OMIT,
        updated_at: typing.Optional[dt.datetime] = OMIT,
        overlap: typing.Optional[int] = OMIT,
        inner_id: typing.Optional[int] = OMIT,
        total_annotations: typing.Optional[int] = OMIT,
        cancelled_annotations: typing.Optional[int] = OMIT,
        total_predictions: typing.Optional[int] = OMIT,
        comment_count: typing.Optional[int] = OMIT,
        unresolved_comment_count: typing.Optional[int] = OMIT,
        last_comment_updated_at: typing.Optional[dt.datetime] = OMIT,
        updated_by: typing.Optional[int] = OMIT,
        file_upload: typing.Optional[int] = OMIT,
        comment_authors: typing.Optional[typing.Sequence[int]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TasksCreateManyResponse:
        """
        Import data as labeling tasks in bulk using this API endpoint. You can use this API endpoint to import multiple tasks.
        One POST request is limited at 250K tasks and 200 MB.
        
        **Note:** Imported data is verified against a project _label_config_ and must
        include all variables that were used in the _label_config_. For example,
        if the label configuration has a _$text_ variable, then each item in a data object
        must include a "text" field.
        <br>
        
        ## POST requests
        
        <hr style="opacity:0.3">
        
        There are three possible ways to import tasks with this endpoint:
        
        ### 1\. **POST with data**
        
        Send JSON tasks as POST data. Only JSON is supported for POSTing files directly.
        Update this example to specify your authorization token and Label Studio instance host, then run the following from
        the command line.
        
        ```bash
        curl -H 'Content-Type: application/json' -H 'Authorization: Token abc123' \
        -X POST 'https://localhost:8080/api/projects/1/import' --data '[{"text": "Some text 1"}, {"text": "Some text 2"}]'
        ```
        
        ### 2\. **POST with files**
        
        Send tasks as files. You can attach multiple files with different names.
        
        - **JSON**: text files in JavaScript object notation format
        - **CSV**: text files with tables in Comma Separated Values format
        - **TSV**: text files with tables in Tab Separated Value format
        - **TXT**: simple text files are similar to CSV with one column and no header, supported for projects with one source only
        
        Update this example to specify your authorization token, Label Studio instance host, and file name and path,
        then run the following from the command line:
        
        ```bash
        curl -H 'Authorization: Token abc123' \
        -X POST 'https://localhost:8080/api/projects/1/import' -F ‘file=@path/to/my_file.csv’
        ```
        
        ### 3\. **POST with URL**
        
        You can also provide a URL to a file with labeling tasks. Supported file formats are the same as in option 2.
        
        ```bash
        curl -H 'Content-Type: application/json' -H 'Authorization: Token abc123' \
        -X POST 'https://localhost:8080/api/projects/1/import' \
        --data '[{"url": "http://example.com/test1.csv"}, {"url": "http://example.com/test2.csv"}]'
        ```
        
        <br>
        
        Parameters
        ----------
        id : int
            A unique integer value identifying this project.
        
        data : typing.Dict[str, typing.Any]
            User imported or uploaded data for a task. Data is formatted according to the project label config. You can find examples of data for your project on the Import page in the Label Studio Data Manager UI.
        
        import_api_id : typing.Optional[int]
        
        annotations : typing.Optional[typing.Sequence[Annotation]]
        
        predictions : typing.Optional[typing.Sequence[Prediction]]
        
        meta : typing.Optional[typing.Dict[str, typing.Any]]
            Meta is user imported (uploaded) data and can be useful as input for an ML Backend for embeddings, advanced vectors, and other info. It is passed to ML during training/predicting steps.
        
        created_at : typing.Optional[dt.datetime]
            Time a task was created
        
        updated_at : typing.Optional[dt.datetime]
            Last time a task was updated
        
        overlap : typing.Optional[int]
            Number of distinct annotators that processed the current task
        
        inner_id : typing.Optional[int]
            Internal task ID in the project, starts with 1
        
        total_annotations : typing.Optional[int]
            Number of total annotations for the current task except cancelled annotations
        
        cancelled_annotations : typing.Optional[int]
            Number of total cancelled annotations for the current task
        
        total_predictions : typing.Optional[int]
            Number of total predictions for the current task
        
        comment_count : typing.Optional[int]
            Number of comments in the task including all annotations
        
        unresolved_comment_count : typing.Optional[int]
            Number of unresolved comments in the task including all annotations
        
        last_comment_updated_at : typing.Optional[dt.datetime]
            When the last comment was updated
        
        updated_by : typing.Optional[int]
            Last annotator or reviewer who updated this task
        
        file_upload : typing.Optional[int]
            Uploaded file used as data source for this task
        
        comment_authors : typing.Optional[typing.Sequence[int]]
            Users who wrote comments
        
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.
        
        Returns
        -------
        TasksCreateManyResponse
            Tasks successfully imported
        
        Examples
        --------
        from label_studio_sdk.client import AsyncLabelStudio
        
        client = AsyncLabelStudio(
            api_key="YOUR_API_KEY",
        )
        await client.tasks.create_many(
            id=1,
            data={},
        )
        """
        _request: typing.Dict[str, typing.Any] = {"data": data}
        if import_api_id is not OMIT:
            _request["id"] = import_api_id
        if annotations is not OMIT:
            _request["annotations"] = annotations
        if predictions is not OMIT:
            _request["predictions"] = predictions
        if meta is not OMIT:
            _request["meta"] = meta
        if created_at is not OMIT:
            _request["created_at"] = created_at
        if updated_at is not OMIT:
            _request["updated_at"] = updated_at
        if overlap is not OMIT:
            _request["overlap"] = overlap
        if inner_id is not OMIT:
            _request["inner_id"] = inner_id
        if total_annotations is not OMIT:
            _request["total_annotations"] = total_annotations
        if cancelled_annotations is not OMIT:
            _request["cancelled_annotations"] = cancelled_annotations
        if total_predictions is not OMIT:
            _request["total_predictions"] = total_predictions
        if comment_count is not OMIT:
            _request["comment_count"] = comment_count
        if unresolved_comment_count is not OMIT:
            _request["unresolved_comment_count"] = unresolved_comment_count
        if last_comment_updated_at is not OMIT:
            _request["last_comment_updated_at"] = last_comment_updated_at
        if updated_by is not OMIT:
            _request["updated_by"] = updated_by
        if file_upload is not OMIT:
            _request["file_upload"] = file_upload
        if comment_authors is not OMIT:
            _request["comment_authors"] = comment_authors
        _response = await self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/projects/{jsonable_encoder(id)}/import"
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            json=jsonable_encoder(_request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(_request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(TasksCreateManyResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic_v1.parse_obj_as(str, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_many_status(
        self, id: int, import_pk: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ProjectImport:
        """
        Return data related to async project import operation

        Parameters
        ----------
        id : int
            A unique integer value identifying this project import.

        import_pk : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProjectImport


        Examples
        --------
        from label_studio_sdk.client import AsyncLabelStudio

        client = AsyncLabelStudio(
            api_key="YOUR_API_KEY",
        )
        await client.tasks.create_many_status(
            id=1,
            import_pk="import_pk",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/projects/{jsonable_encoder(id)}/imports/{jsonable_encoder(import_pk)}/",
            ),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(ProjectImport, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list(
        self,
        *,
        page: typing.Optional[int] = None,
        page_size: typing.Optional[int] = None,
        view: typing.Optional[int] = None,
        project: typing.Optional[int] = None,
        resolve_uri: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPager[typing.List[typing.Dict[str, typing.Any]]]:
        """
        Retrieve a list of tasks with pagination for a specific view or project, by using filters and ordering.

        Parameters
        ----------
        page : typing.Optional[int]
            A page number within the paginated result set.

        page_size : typing.Optional[int]
            Number of results to return per page.

        view : typing.Optional[int]
            View ID

        project : typing.Optional[int]
            Project ID

        resolve_uri : typing.Optional[bool]
            Resolve task data URIs using Cloud Storage

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPager[typing.List[typing.Dict[str, typing.Any]]]
            Tasks list

        Examples
        --------
        from label_studio_sdk.client import AsyncLabelStudio

        client = AsyncLabelStudio(
            api_key="YOUR_API_KEY",
        )
        await client.tasks.list()
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/tasks/"),
            params=encode_query(
                jsonable_encoder(
                    remove_none_from_dict(
                        {
                            "page": page,
                            "page_size": page_size,
                            "view": view,
                            "project": project,
                            "resolve_uri": resolve_uri,
                            **(
                                request_options.get("additional_query_parameters", {})
                                if request_options is not None
                                else {}
                            ),
                        }
                    )
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            _parsed_response = pydantic_v1.parse_obj_as(TasksListResponse, _response.json())  # type: ignore
            _has_next = True
            _get_next = lambda: self.list(
                page=page + 1 if page is not None else 1,
                page_size=page_size,
                view=view,
                project=project,
                resolve_uri=resolve_uri,
                request_options=request_options,
            )
            _items = _parsed_response.tasks
            return AsyncPager(has_next=_has_next, items=_items, get_next=_get_next)
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create(self, *, request: BaseTask, request_options: typing.Optional[RequestOptions] = None) -> BaseTask:
        """
        Create a new labeling task in Label Studio.

        Parameters
        ----------
        request : BaseTask

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BaseTask


        Examples
        --------
        from label_studio_sdk import BaseTask
        from label_studio_sdk.client import AsyncLabelStudio

        client = AsyncLabelStudio(
            api_key="YOUR_API_KEY",
        )
        await client.tasks.create(
            request=BaseTask(
                data={},
            ),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="POST",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/tasks/"),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            json=jsonable_encoder(request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(BaseTask, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(
        self, id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> DataManagerTaskSerializer:
        """
        Get task data, metadata, annotations and other attributes for a specific labeling task by task ID.

        Parameters
        ----------
        id : str
            Task ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        DataManagerTaskSerializer


        Examples
        --------
        from label_studio_sdk.client import AsyncLabelStudio

        client = AsyncLabelStudio(
            api_key="YOUR_API_KEY",
        )
        await client.tasks.get(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="GET",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tasks/{jsonable_encoder(id)}/"),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(DataManagerTaskSerializer, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(self, id: str, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Delete a task in Label Studio. This action cannot be undone!

        Parameters
        ----------
        id : str
            Task ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from label_studio_sdk.client import AsyncLabelStudio

        client = AsyncLabelStudio(
            api_key="YOUR_API_KEY",
        )
        await client.tasks.delete(
            id="id",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="DELETE",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tasks/{jsonable_encoder(id)}/"),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            json=jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))
            if request_options is not None
            else None,
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(
        self, id: str, *, request: TaskSimple, request_options: typing.Optional[RequestOptions] = None
    ) -> TaskSimple:
        """
        Update the attributes of an existing labeling task.

        Parameters
        ----------
        id : str
            Task ID

        request : TaskSimple

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TaskSimple


        Examples
        --------
        from label_studio_sdk import TaskSimple
        from label_studio_sdk.client import AsyncLabelStudio

        client = AsyncLabelStudio(
            api_key="YOUR_API_KEY",
        )
        await client.tasks.update(
            id="id",
            request=TaskSimple(
                data={},
            ),
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            method="PATCH",
            url=urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/tasks/{jsonable_encoder(id)}/"),
            params=encode_query(
                jsonable_encoder(
                    request_options.get("additional_query_parameters") if request_options is not None else None
                )
            ),
            json=jsonable_encoder(request)
            if request_options is None or request_options.get("additional_body_parameters") is None
            else {
                **jsonable_encoder(request),
                **(jsonable_encoder(remove_none_from_dict(request_options.get("additional_body_parameters", {})))),
            },
            headers=jsonable_encoder(
                remove_none_from_dict(
                    {
                        **self._client_wrapper.get_headers(),
                        **(request_options.get("additional_headers", {}) if request_options is not None else {}),
                    }
                )
            ),
            timeout=request_options.get("timeout_in_seconds")
            if request_options is not None and request_options.get("timeout_in_seconds") is not None
            else self._client_wrapper.get_timeout(),
            retries=0,
            max_retries=request_options.get("max_retries") if request_options is not None else 0,  # type: ignore
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(TaskSimple, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
